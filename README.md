# reaction-meme-server
This is a Flask server hosted on Vercel designed to manage my reaction meme library. It provides API end points to download, search and add new reaction memes to the library.

It is hosted on Vercel at: https://reaction-meme-server.vercel.app/

## Using the API
**NEEDS TO BE UPDATED**
### Access Tokens
Anyone can download or search for memes, but as a security measure only people with access tokens can add new memes to the server.

The access tokens are generated and managed by me manually, so if you would like one, reach out.

Access tokens must be included in requests for adding memes (either registering a meme or uploading its binary content). They are to be included in the header of the HTTP request with the key `Access-Token`.

### Download Memes
Each meme in the repository has an ID, to download a meme with a given ID, query the API endpoint: `memes/download/<id>` where `<id>` is the meme ID.

The API will automatically redirect you to the URL which hosts the meme content.

### Search for Memes
To search for a meme, use the endpoint `memes/search`, where the query is encoded as a URL string parameter e.g. to search for "slut", it would be `memes/search?query=slut`.

Additionally, you can pass a limit parameter as well e.g. `memes/search?query=slut&limit=10`

The query will be used to search for both meme names and their associated tags. For more information, refer to the Software Details section.

The endpoint responds with a JSON dictionary with key `results` which maps to the list of results for the search query.  Each item in the results list contains the meme name, ID and its content URL (the URL where the meme can be downloaded from).

```python
import requests
resp = requests.get('https://reaction-meme-server.vercel.app/memes/search?query=slut&limit=15')

results = resp.json()['results']
for res in results:
    print('Name: "{}", ID: {}, URL: {}'.format(res['name'], res['id'], res['url']))
```

### Add Memes
***Adding memes requires an access token, refer to the Access Token section.***

Adding a meme is a two-step process. First you register the meme information (name and tags) into the database and then upload the meme media to the hosting service.

To register a new meme into the database, use a HTTP POST on the endpoint `memes/add` with a JSON body that contains the following keys:
- `name (string)` - The name to be associated with the meme, does not have to include a file extension and can include spaces. Make it descriptive, as it is also used in search
- `fileExt (string)` - The file extension of the meme media file, used in internal processes
- `tags (string)` - The list of comma-separated tags used to describe the meme, these are key to searching. An example of tags would be `billie eilish,gay,happy`.

***Note your HTTP request must include your access token or the server will reject the request.***

If successful, the server will respond with a JSON package that contains the key `uploadURL` (among other information including the meme ID). The upload URL is a unique URL generated by the server for you to upload the meme media content.

Make a HTTP post to the given upload URL, uploading the meme binary content as an HTTP File (i.e. a file body for the HTTP request). ***Your HTTP request must include your access token or the server will reject the request.***

If successful, the server will respond with the URL of the now uploaded meme can be downloaded from (It is a JSON response which contains a `url` key).

Here is a python example of adding a meme:

```python
import requests    
with open('belugaWhale.jpg', 'rb') as file:
    memeBinaryData = file.read()

memeName = 'beluga whale scaring child'
memeTags = 'beluga whale,scare,evil,satisfied,petty,child,crying,aquarium,fish,water'
memeFileExt = 'jpg'

# Enter your access token here
accessToken = "abc123"

# Register the meme to the server with your access token in the header
resp = requests.post("https://reaction-meme-server.vercel.app/memes/add",
                     headers = {'Access-Token': accessToken}, 
                     json={'name': memeName, 'tags': memeTags, 'fileExt': memeFileExt})

# Use the upload URL to upload the meme binary dara
uploadUrl = resp.json()['uploadURL']
resp2 = requests.post(uploadUrl, 
                      headers = {'Access-Token': accessToken},
                      data=memeBinaryData)
```

# Configuration Notes
## Deployment Notes
The current setup of the project has the following deployment configured:
- The server is hosted on Vercel under my account as the reaction-meme-server project
- The PushBullet account used for the file server is hosted with my bot email address.
- Cloudinary hosts the meme media files, tied to my GitHub email

## Config Variables
Access tokens, the development environment and other environment constants are managed with the ServerConfig class (apiutils/ServerConfig).

This class stores relevant information in its static class members, which we can call "config variables". These class members are accessed in other areas of the API to determine the behaviour. You can initialize the config variables by:
- Setting the correct environment variables (`ServerConfig.setConfigFromEnv`)
- Passing a JSON file with the correct key-value pairs (`ServerConfig.setConfigFromJSON`)

The following keys (or environment variable names) are checked for when initializing the config variables
- `RMSVR_PROJECT_ENVIRONMENT`
  - Required
  - The running environment of the project
  - Can be either `development` or `production`
- `RMSVR_ALLOWED_ACCESS_TOKENS`
  - Required
  - The access tokens which are allowed to edit/add new memes to the server
  - Are `;` separated
- `RMSVR_CLOUDINARY_CLOUD_NAME`
  - Required, if using Cloudinary
  - The name of the server on your cloudinary account
- `RMSVR_CLOUDINARY_API_KEY`
  - Required, if using Cloudinary
  - The API key of the cloudinary server (Cloudinary Console > Settings > Access Keys)
- `RMSVR_CLOUDINARY_API_SECRET`
  - Required, if using Cloudinary
  - The API secret of the cloudinary server (Cloudinary Console > Settings > Access Keys)
- `RMSVR_MEME_DB`
  - Optional
  - What type of DB will be used by the library
  - Can be `json` (default)
- `RMSVR_MEME_STORAGE`
  - Optional
  - What type of meme storage is used by the library
  - Can be:
    - `cloudinary`: default, for Cloudinary hosting
    - `local` : For local meme storage server
- `RMSVR_JSON_DB_FILE_STORAGE`
  - Optional
  - What type of file storage is used by the JSON Meme DB
  - Can be:
    - `pbfs`: default, uses the PushBullet File Server
    - `local`: Saves it to local repository file
- `RMSVR_PBFS_ACCESS_TOKEN`
  - Required, if using PushBullet
  - The access token of the PushBullet account
- `RMSVR_PBFS_SERVER_IDENTIFIER`
  - Required, if using PushBullet
  - The server identifier of the

## Runtime Environments
### Runtime Overrides
The config variables determine the components used at runtime, however there can be overrides done to config variables using some special environment variables:

- `JSON_ENV`
  - If present, it will be treated as a file path to the JSON file which will be used to initialize the config variables
- `OVERRIDE_RMSVR_MEME_DB`
  - Overrides the database used by the meme library for the memes
  - Options:
    - See options for `RMSVR_MEME_DB` config variable
- `OVERRIDE_RMSVR_JSON_DB_FILE_STORAGE`
  - Overrides the file storage used by the JSON Database
  - Options:
    - See options for `RMSVR_JSON_DB_FILE_STORAGE` config variable
- `OVERRIDE_RMSVR_MEME_STORAGE`
  - Overrides the meme storage (where memes are uploaded to)
  - Options:
    - See options for `RMSVR_MEME_STORAGE` config variable
- `INIT_LIB_FROM_CATALOG_OVERRIDE`
  - If the env var exists, the library will be initialized from data/catalog.csv
  - If it does not exist, the library will be initialized from the connected meme DB

### Available Runtime Configurations
There are different runtime configurations that have been made in PyCharm, which use the environment variables:
- `api (prod)`
  - Mirrors server running in production environment:
    - File Storage: PBFS (ReactionMemeServer PB device)
    - Meme DB: JSON Meme DB
    - Meme Storage: Cloudinary
    - Library Source: Loaded From DB
  - Env Vars
    - `JSON_ENV = C:\Users\omnic\local\GitRepos\reaction-meme-server\devenv\prodenv.json`


- `api (dev)`
  - Server in development
    - File Storage: PBFS (ReactionMemeServer-DevEnv PB device)
    - Meme DB: JSON Meme DB
    - Meme Storage: Local
    - Library Source: Loaded From DB
  - Env Vars
    - `JSON_ENV = C:\Users\omnic\local\GitRepos\reaction-meme-server\devenv.json`

- `api (db=json, ms=local, fs=local)`
  - Server in development
    - File Storage: Local (RepoLocalFileStorage)
    - Meme DB: JSON Meme DB
    - Meme Storage: Local
    - Library Source: Loaded From DB
  - Env Vars
    - `JSON_ENV = C:\Users\omnic\local\GitRepos\reaction-meme-server\devenv\devenv.json`
    - `OVERRIDE_RMSVR_JSON_DB_FILE_STORAGE = local`
    - `OVERRIDE_RMSVR_MEME_DB = json`
    - `OVERRIDE_RMSVR_MEME_STORAGE = local`

- `api (db=json, ms=cloud, fs=local)`
  - Server in development
    - File Storage: Local (RepoLocalFileStorage)
    - Meme DB: JSON Meme DB
    - Meme Storage: Cloudinary
    - Library Source: Loaded From DB
  - Env Vars
    - `JSON_ENV = C:\Users\omnic\local\GitRepos\reaction-meme-server\devenv\devenv.json`
    - `OVERRIDE_RMSVR_JSON_DB_FILE_STORAGE = local`
    - `OVERRIDE_RMSVR_MEME_DB = json`
    - `OVERRIDE_RMSVR_MEME_STORAGE = cloudinary`

# Software Details
***This section is still in development, added for posterity***
## `MemeLibrary`
The main class being used for meme management is the MemeLibrary class (`apiutils/MemeManagement/MemeLibrary.py). This class is initialized and handles searching for memes, adding new memes to the library and so on.

The MemeLibrary class is more like a coordinator which uses other classes to complete the required tasks, the classes involved are:
- MemeLibraryItem
- MemeUploaderInterface : The uploader argument in MemeLibrary constructor
- MemeDBInterface : The db argument in MemeLibrary constructor

## `MemeLibraryItem`
Like a book from the library, a MemeLibraryItem is an object which contains all relevant information about a meme, this includes its name, file extension, tags and URL.

The class provides getter and setter methods for a MemeLibraryItem, but it is important to note that MemeLibraryItem instances **are not linked to the library**. That is, changes to a MemeLibraryItem do not affect the actual library or underlying database. The class is primarily used as a data container for memes.

## `MemeUploaderInterface`
This is an "interface" used by MemeLibrary to handle uploading the binary content of meme files to the hosting service in use.

Classes which implement the MemeUploaderInterface can be passed to MemeLibrary as the uploader. Using an interface allows different hosting solutions to be implemented and used in MemeLibrary without having to change any code within the class (a plug-and-play).

There are two classes which implement the MemeUploader interface:
- CloudinaryUploader (`apiutils/MemeUploaderClasses/CloudinaryUploader`) handles uploadig to cloudinary.
- LocalStorageUploader (`apiutils/MemeUploaderClasses/LocalStorageUploader`) handles uploading as saving onto your local device. It's specifically implemented for a testing environment.

### Local media hosting with `LocalStorageUploader`
LocalStorageUploader is designed to work with the local meme storage server configuration which allows me to mimic cloud hosting but instead saving locally. Read more in `localMemeStorage\README.md`

## `MemeDBInterface`
This interface provides the similar plug-and-play solution but instead for the database used within MemeLibrary. The meme database stores the related information for each meme, which includes the meme's:
- ID: The unique ID in the database for the meme entry
- Name: A descriptive name for the meme
- Tags: The set of tags associated with the eme
- Cloud ID: The ID used for the meme in the cloud hosting service
- Cloud URL: The URL from which the meme can be downloaded

Any implementing classes for the MemeDBInterface will have these fields to some degree, the specific implementation will vary. For this there is only one implementing class available:
- JSONMemeDB : A database implementation just using a JSON file





